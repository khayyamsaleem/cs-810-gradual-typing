#+TITLE: Additional Slides
#+LATEX_HEADER: \usepackage{syntax}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \setlength{\grammarparsep}{20pt plus 1pt minus 1pt}
#+LATEX_HEADER: \setlength{\grammarindent}{12em}
#+LATEX_CLASS: beamer
#+BEAMER_FRAME_LEVEL: 2

* Implementation -- Grammar

#+ATTR_LATEX: align=|l|c|l|
| $\synt{ground-type}$ | ::= | =number= | $\textbar$ | =boolean= | $\textbar$ | =char= | $\textbar$ | =string= |

#+ATTR_LATEX: align=|l|c|l|
| $\synt{type}$ | ::=        | =any=                                       |
|               | $\textbar$ | $\synt{ground-type}$                        |
|               | $\textbar$ | $(* \synt{type} \synt{type} \dots \synt{type})$ |
|               | $\textbar$ | $\text{list} \synt{type}$                   |
|               | $\textbar$ | $\rightarrow \; \synt{type} \synt{type}$              |
|               | $\textbar$ | $\rightarrow n \; \synt{type} \synt{type}$            |

* Implementation -- Grammar

#+ATTR_LATEX: align=|l|c|l|
| $\synt{expression}$ | ::=        | \dots                                                                                        |
|                     | $\textbar$ | $(\mathtt{fn} \;(: \synt{variable} \synt{type}) \synt{expression})$                      |
|                     | $\textbar$ | $(\mathtt{fn} \;(: \synt{variable} \synt{type}) \;(: \synt{type}) \synt{expression})$    |
|                     | $\textbar$ | $(\mathtt{listof} \;(:\synt{type}) \synt{expression}*)$                                  |
|                     | $\textbar$ | $(\mathtt{pair} \synt{expression} \synt{expression})$                                    |
|                     | $\textbar$ | $(\mathtt{defvar} \;(: \synt{variable} \synt{type}) \synt{expression})$                  |
|                     | $\textbar$ | $(\mathtt{defn} \;(: \synt{variable} \synt{type}) (\synt{variable}*) \synt{expression})$ |


* Implementation -- Opeartional Semantics

- Scheme's operational semantics
- Macros enable type annotations
- Each macro simply performs erasure on 'itself'

* Implementation -- Operational Semantics

$$\frac{}{\texttt{(fn (: x s) M)} \rightarrow \texttt{(lambda (x) M)}}$$

$$\frac{}{\texttt{(listof (: s) m n ...)} \rightarrow \texttt{(list m n ...)}}$$

$$\frac{}{\texttt{(defvar (: x s) M)} \rightarrow \texttt{(define (x) M)}}$$

$$\frac{}{\texttt{(pair x y)} \rightarrow \texttt{(cons x y)}}$$

$$\frac{}{\texttt{(defn (: f s) (x y ...) M)} \rightarrow \texttt{(define (f x y ...) M)}}$$

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax listof
  (syntax-rules (:)
    ((_ (: type) e1 ...)
     (list e1 ...))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax fn-erase
  (syntax-rules (:)
    ((_ (: v type))
     '(v))
    ((_ ((: v type) v2 ...))
     `(v ,@(fn-erase v2 ...)))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax fn
  (syntax-rules (:)
    ((_ (: v type) (: return) body ...)
     (lambda (v) body ...))
    ((_ (: v type) body ...)
     (lambda (v) body ...))
    ((_ ((: v type) v2 ...) (: return) body ...)
     (fn ((: v type) v2 ...) body ...))
    ((_ ((: v type) v2 ...) body ...)
     (let ((env (the-environment)))
       (eval `(lambda ,O(fn-erase ((: v type) v2 ...)) 
		body ...) env)))
    ((_ () body ...)
     (lambda () body ...))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax defn
  (syntax-rules (:)
    ((_ (: name type) (arg1 . args) body ...)
     (define (name arg1 . args) body ...))))
#+END_SRC

* Implementation -- Typing Rules

** 
$$\frac{\Gamma, x : \sigma \vdash M : \tau}{\Gamma \vdash \lambda x : \sigma . M : \sigma \rightarrow \tau}$$

* Implementation -- Typing Rules

$$\frac{\Gamma \vdash M : \sigma \rightarrow \tau \quad \Gamma \vdash N : \tau \quad \sigma \sim \tau \quad \tau \neq \thinspace ? \text{ when } \sigma \neq \thinspace ?}{\Gamma \vdash M \; N : \tau}$$

- Design decision we had to make
- Otherwise =((fn (: x any) (+ x 1)) #t)= would type check
- In /Gradual Typing for Functional Languages/ this results in a /CastError/ which is addressed by the operational semantics
- We don't have control over Scheme's operational semantics in our case


* Implementation -- Typing Rules

** 

$$\frac{\Gamma \vdash M : \sigma_1 * \sigma_2 * \dots * \sigma_n \rightarrow \tau \qquad \Gamma \vdash N_{i}^{i \in \{1,2,\dots,n\} } : \sigma_i}{\Gamma \vdash (M \, N_1 \, N_2 \dots \, N_n) : \tau}$$

** 

$$\frac{\Gamma \vdash M : \sigma \underset{n}{\rightarrow} \tau \qquad \Gamma \vdash N_{i}^{i \in \{1,2,\dots,n\} } : \sigma}{\Gamma \vdash (M \, N_1 \, N_2 \dots \, N_n) : \tau}$$

** 
- $\underset{n}{\rightarrow}$ is not entirely syntactic sugar
- Helps deal with Scheme's multiple arity functions

* Scheme's multiple arity functions

#+BEGIN_SRC scheme
(+)         ; => 0
(+ 1)       ; => 1
(+ 1 2 3 4) ; => 10

(*)         ; => 1
(* 1)       ; => 1
(* 1 2 3 4) ; => 24

(>)         ; => #t
(> 1)       ; => #t
(> 1 2)     ; => #f
(> 3 2 1 0) ; => #t 


(: + (->n number number))
(: * (->n number number))
(: > (->n number boolean))
#+END_SRC


