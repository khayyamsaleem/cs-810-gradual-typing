#+TITLE: Additional Slides
#+LATEX_HEADER: \usepackage{syntax}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \setlength{\grammarparsep}{20pt plus 1pt minus 1pt}
#+LATEX_HEADER: \setlength{\grammarindent}{12em}
#+LATEX_CLASS: beamer
#+BEAMER_FRAME_LEVEL: 2

* Implementation

1) Terms
2) Types
3) Typing Rules
4) Operational Semantics


* Implementation -- Terms
:PROPERTIES:
:BEAMER_OPT: fragile,allowframebreaks
:END:

#+BEGIN_LaTeX
\begin{grammar}
<statement> ::= <ident> = <expr>
\alt for <ident> = <expr> to <expr> do <statement>
\alt { <stat-list> }
\end{grammar}
#+END_LaTeX


* Implementation
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

#+BEGIN_LaTeX
\begin{grammar}
\sigma,\tau ::= \mathbb{N}
\alt \mathbb{B}
\alt \mathbb{S}
\alt \mathbb{C}
\alt {list}_{\sigma}
\alt (\sigma_1 * \sigma_2 * \dots * \sigma_n)
\alt \sigma \rightarrow \tau
\alt \sigma \underset{n}{\rightarrow} \tau
\end{grammar}
#+END_LaTeX

* Implementation

#+BEGIN_LaTeX
\begin{tabular}{lcl}
\synt{term} & ::= & \synt{term1}\\
& \textbar & \synt{term2}\\
\end{tabular}
#+END_LaTeX

#+ATTR_LATEX: align=|l|c|l|
| $\synt{term}$ | ::=        | $\synt{term1}$ |
|               | $\textbar$ | $\synt{term2}$ |


* Implementation -- Grammar

#+ATTR_LATEX: align=|l|c|l|
| $\gamma$ | ::= | $\mathbb{N}$ | $\mathbb{B}$ | $\mathbb{C}$ | $\mathbb{S}$ |

#+ATTR_LATEX: align=|l|c|l|
| $\sigma$ | ::=        | ?                     |
|     | $\textbar$ | $\gamma$                   |
|     | $\textbar$ | $(\sigma_1 * \sigma_2 * \dots * \sigma_n)$  |
|     | $\textbar$ | $\text{list} \sigma$       |
|     | $\textbar$ | $\sigma \rightarrow \tau$               |
|     | $\textbar$ | $\sigma \underset{n}{\rightarrow} \tau$ |

* Implementation -- Grammar

#+ATTR_LATEX: align=|l|c|l|
| $\synt{ground-type}$ | ::= | =number= | $\textbar$ | =boolean= | $\textbar$ | =char= | $\textbar$ | =string= |

#+ATTR_LATEX: align=|l|c|l|
| $\synt{type}$ | ::=        | =any=                                       |
|               | $\textbar$ | $\synt{ground-type}$                        |
|               | $\textbar$ | $(* \synt{type} \synt{type} \dots \synt{type})$ |
|               | $\textbar$ | $\text{list} \synt{type}$                   |
|               | $\textbar$ | $\rightarrow \; \synt{type} \synt{type}$              |
|               | $\textbar$ | $\rightarrow n \; \synt{type} \synt{type}$            |

* Implementation -- Grammar

#+ATTR_LATEX: align=|l|c|l|
| $\synt{expression}$ | ::=        | \dots                                                                                        |
|                     | $\textbar$ | $(\mathtt{fn} \;(: \synt{variable} \synt{type}) \synt{expression})$                      |
|                     | $\textbar$ | $(\mathtt{fn} \;(: \synt{variable} \synt{type}) \;(: \synt{type}) \synt{expression})$    |
|                     | $\textbar$ | $(\mathtt{listof} \;(:\synt{type}) \synt{expression}*)$                                  |
|                     | $\textbar$ | $(\mathtt{pair} \synt{expression} \synt{expression})$                                    |
|                     | $\textbar$ | $(\mathtt{defvar} \;(: \synt{variable} \synt{type}) \synt{expression})$                  |
|                     | $\textbar$ | $(\mathtt{defn} \;(: \synt{variable} \synt{type}) (\synt{variable}*) \synt{expression})$ |


* Implementation -- Opeartional Semantics

- Scheme's operational semantics
- Macros enable type annotations
- Each macro simply performs erasure on 'itself'

* Implementation -- Operational Semantics

$$\frac{}{\texttt{(fn (: x s) M)} \rightarrow \texttt{(lambda (x) M)}}$$

$$\frac{}{\texttt{(listof (: s) m n ...)} \rightarrow \texttt{(list m n ...)}}$$

$$\frac{}{\texttt{(defvar (: x s) M)} \rightarrow \texttt{(define (x) M)}}$$

$$\frac{}{\texttt{(pair x y)} \rightarrow \texttt{(cons x y)}}$$

$$\frac{}{\texttt{(defn (: f s) (x y ...) M)} \rightarrow \texttt{(define (f x y ...) M)}}$$

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax listof
  (syntax-rules (:)
    ((_ (: type) e1 ...)
     (list e1 ...))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax fn-erase
  (syntax-rules (:)
    ((_ (: v type))
     '(v))
    ((_ ((: v type) v2 ...))
     `(v ,@(fn-erase v2 ...)))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax fn
  (syntax-rules (:)
    ((_ (: v type) (: return) body ...)
     (lambda (v) body ...))
    ((_ (: v type) body ...)
     (lambda (v) body ...))
    ((_ ((: v type) v2 ...) (: return) body ...)
     (fn ((: v type) v2 ...) body ...))
    ((_ ((: v type) v2 ...) body ...)
     (let ((env (the-environment)))
       (eval `(lambda ,O(fn-erase ((: v type) v2 ...)) 
		body ...) env)))
    ((_ () body ...)
     (lambda () body ...))))
#+END_SRC

* Implementation -- Operational Semantics

#+BEGIN_SRC scheme
(define-syntax defn
  (syntax-rules (:)
    ((_ (: name type) (arg1 . args) body ...)
     (define (name arg1 . args) body ...))))
#+END_SRC

* Implementation -- Typing Rules


* Implementation -- Typing Rules

$$\frac{\Gamma \vdash M : \sigma \rightarrow \tau \quad \Gamma \vdash N : \tau \quad \sigma \sim \tau \quad \tau \neq \thinspace ? \text{ when } \sigma = \thinspace ?}{\Gamma \vdash M \; N : \tau}$$

- Design decision we had to make
- Otherwise =((fn (: x any) (+ x 1)) #t)= would type check
- In /Gradual Typing for Functional Languages/ this results in a /CastError/ which is addressed
in the operational semantics


